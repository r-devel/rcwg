[
    {
        "subtype": "bot_message",
        "text": "*[Bug 18963] Allow packages to provide serialization hooks for R objects*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18963>\n\n--- Comment #4 from Kevin Ushey (<mailto:kevinushey@gmail.com|kevinushey@gmail.com>) ---\n&gt; I usually handle this sort of thing by including an external pointer in the object. When those are unserialized the pointer value is NULL, so a function using the object can check if the object went through a serialize\/unserialize cycle and needs to be reconstituted in some way. Not suitable for all situations, but it is an option that is available now.\n\nIn my view, this becomes a bit painful since now every function in a package\nthat uses such an object now needs to perform this validation. It's also worth\nsaying that an unserialized object might not always be destined to be used\ndirectly via the functions \/ APIs provided by the package that created it; e.g.\na user might be defining their own functions, there might be extension packages\nusing these objects, and so on. It's an easy operation to forget.\n\n&gt; I don't think the proposed solution would help much, because it is strictly limited to explicit serialization of a single object with saveRDS, so not really an interesting case as you could simply provide your own method for that instead - and not addressing the original issue of hitting any other serialization points.\n\nMy thought was to allow for package-defined callbacks to run to transform an R\nobject before it is serialized just around the core serialization code itself;\nin serialize.c, there could be some pre-serialization transformation performed\nin WriteItem, and a similar reversing transformation after an item is read via\nReadItem. This would avoid touching the \"core\" serialization code, while\nallowing the transformations to happen in all serialization code paths\n(save\/load; readRDS\/saveRDS; serialize\/unserialize).\n\nBeyond just external pointers, I think there are other potential benefits here\n-- e.g. some objects could have alternate compact representations, and\nserializing those compact representations could be more space-efficient and\ntime-efficient.\n\n&gt; I can see the value of something like this, but it would be challenging to design. The fundamental problem is that at the point where an object with an S3 class is unserialized there is no information available about what package(s) need to be loaded to provide the unwrap method. There would have to be some convention about adding such information at the wrap stage for this to work.\n\nI was thinking that `wrap()` would tag the transformed object, probably via an\nattribute with some special name, with details about the transformation (the\npackage used? the method used?) and that information would be used to load the\nnecessary packages after unserialization, but before `unwrap()` is invoked on\nthe unserialized object.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1762452274.208859",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A0n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18963] Allow packages to provide serialization hooks for R objects",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18963"
                            },
                            {
                                "type": "text",
                                "text": "\n\n--- Comment #4 from Kevin Ushey ("
                            },
                            {
                                "type": "link",
                                "url": "mailto:kevinushey@gmail.com",
                                "text": "kevinushey@gmail.com"
                            },
                            {
                                "type": "text",
                                "text": ") ---"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I usually handle this sort of thing by including an external pointer in the object. When those are unserialized the pointer value is NULL, so a function using the object can check if the object went through a serialize\/unserialize cycle and needs to be reconstituted in some way. Not suitable for all situations, but it is an option that is available now."
                            }
                        ],
                        "contains_padding": true
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nIn my view, this becomes a bit painful since now every function in a package\nthat uses such an object now needs to perform this validation. It's also worth\nsaying that an unserialized object might not always be destined to be used\ndirectly via the functions \/ APIs provided by the package that created it; e.g.\na user might be defining their own functions, there might be extension packages\nusing these objects, and so on. It's an easy operation to forget.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think the proposed solution would help much, because it is strictly limited to explicit serialization of a single object with saveRDS, so not really an interesting case as you could simply provide your own method for that instead - and not addressing the original issue of hitting any other serialization points."
                            }
                        ],
                        "contains_padding": true
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nMy thought was to allow for package-defined callbacks to run to transform an R\nobject before it is serialized just around the core serialization code itself;\nin serialize.c, there could be some pre-serialization transformation performed\nin WriteItem, and a similar reversing transformation after an item is read via\nReadItem. This would avoid touching the \"core\" serialization code, while\nallowing the transformations to happen in all serialization code paths\n(save\/load; readRDS\/saveRDS; serialize\/unserialize).\n\nBeyond just external pointers, I think there are other potential benefits here\n-- e.g. some objects could have alternate compact representations, and\nserializing those compact representations could be more space-efficient and\ntime-efficient.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I can see the value of something like this, but it would be challenging to design. The fundamental problem is that at the point where an object with an S3 class is unserialized there is no information available about what package(s) need to be loaded to provide the unwrap method. There would have to be some convention about adding such information at the wrap stage for this to work."
                            }
                        ],
                        "contains_padding": true
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nI was thinking that "
                            },
                            {
                                "type": "text",
                                "text": "wrap()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would tag the transformed object, probably via an\nattribute with some special name, with details about the transformation (the\npackage used? the method used?) and that information would be used to load the\nnecessary packages after unserialization, but before "
                            },
                            {
                                "type": "text",
                                "text": "unwrap()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is invoked on\nthe unserialized object."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "subtype": "bot_message",
        "text": "*[Bug 18964] New: Examples for untf=TRUE in ?abline*\n<https:\/\/bugs.r-project.org\/show_bug.cgi?id=18964>\n\n            Bug ID: 18964\n           Summary: Examples for untf=TRUE in ?abline\n           Product: R\n           Version: R-devel (trunk)\n          Hardware: All\n                OS: All\n            Status: UNCONFIRMED\n          Severity: minor\n          Priority: P5\n         Component: Graphics\n          Assignee: <mailto:R-core@R-project.org|R-core@R-project.org>\n          Reporter: <mailto:michaelchirico4@gmail.com|michaelchirico4@gmail.com>\n\nCreated attachment 3559\n  --&gt; <https:\/\/bugs.r-project.org\/attachment.cgi?id=3559&amp;action=edit>\nA small example of untf=TRUE\n\nI found myself struggling with adding lines to a log-log plot and eventually\nrealized `abline(untf=TRUE)` is perfect for my use case (translating a simple\nx-y plot with some abline overlays into logx-logy space), but I had to come up\nwith the basic examples myself to be convinced of this.\n\nI think those in the attached patch are illustrative -- especially in the\nlog-log plot where we see the untf=FALSE lines visually match those in the\nuntransformed space.",
        "username": "r-bugs notifier",
        "icons": {
            "emoji": ":robot_face:"
        },
        "type": "message",
        "ts": "1762456946.392609",
        "bot_id": "B06769YJX9Q",
        "app_id": "A024R9PQM",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D7G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[Bug 18964] New: Examples for untf=TRUE in ?abline",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/show_bug.cgi?id=18964"
                            },
                            {
                                "type": "text",
                                "text": "\n\n            Bug ID: 18964\n           Summary: Examples for untf=TRUE in ?abline\n           Product: R\n           Version: R-devel (trunk)\n          Hardware: All\n                OS: All\n            Status: UNCONFIRMED\n          Severity: minor\n          Priority: P5\n         Component: Graphics\n          Assignee: "
                            },
                            {
                                "type": "link",
                                "url": "mailto:R-core@R-project.org",
                                "text": "R-core@R-project.org",
                                "unsafe": true
                            },
                            {
                                "type": "text",
                                "text": "\n          Reporter: "
                            },
                            {
                                "type": "link",
                                "url": "mailto:michaelchirico4@gmail.com",
                                "text": "michaelchirico4@gmail.com"
                            },
                            {
                                "type": "text",
                                "text": "\n\nCreated attachment 3559\n  --> "
                            },
                            {
                                "type": "link",
                                "url": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3559&amp;action=edit",
                                "text": "https:\/\/bugs.r-project.org\/attachment.cgi?id=3559&action=edit"
                            },
                            {
                                "type": "text",
                                "text": "\nA small example of untf=TRUE\n\nI found myself struggling with adding lines to a log-log plot and eventually\nrealized "
                            },
                            {
                                "type": "text",
                                "text": "abline(untf=TRUE)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is perfect for my use case (translating a simple\nx-y plot with some abline overlays into logx-logy space), but I had to come up\nwith the basic examples myself to be convinced of this.\n\nI think those in the attached patch are illustrative -- especially in the\nlog-log plot where we see the untf=FALSE lines visually match those in the\nuntransformed space."
                            }
                        ]
                    }
                ]
            }
        ]
    }
]